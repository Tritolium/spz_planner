 

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate, NetworkFirst, CacheFirst, Strategy } from "workbox-strategies"

class CacheNetworkRace extends Strategy {
	_handle(request, handler) {
		const fetchAndCachePutDone = handler.fetchAndCachePut(request)
		const cacheMatchDone = handler.cacheMatch(request)

		return new Promise((resolve, reject) => {
			fetchAndCachePutDone.then(resolve)
			cacheMatchDone.then(response => response && resolve(response))

			// Reject if both network and cache error or find no response
			Promise.allSettled([fetchAndCachePutDone, cacheMatchDone]).then(results => {
				const [fetchAndCachePutResult, cacheMatchResult] = results
				if (fetchAndCachePutResult.status === "rejected" && !cacheMatchResult.value) {
					reject(fetchAndCachePutResult.reason)
				}
			})
		})
	}
}

cleanupOutdatedCaches()

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) => url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: "images",
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
)

registerRoute(
	({ url }) => url.pathname.startsWith("/api/v0/attendence"),
	new NetworkFirst({
		cacheName: "attendence",
		networkTimeoutSeconds: 3,
		plugins: [
			new ExpirationPlugin({ maxAgeSeconds: 600 }),
		],
	})
)

registerRoute(
	({ url }) => url.pathname.startsWith("/api/login.php"),
	new CacheNetworkRace({
		cacheName: "login"
	})
)

registerRoute(
	({ url }) => url.pathname.startsWith("/api/v0/events"),
	new NetworkFirst({ // prefer network, fallback to cache
		cacheName: "events",
    networkTimeoutSeconds: 3,
		plugins: [
			new ExpirationPlugin({ maxAgeSeconds: 604800 }), // 7 days
		],
	})
)

registerRoute(
	({ url }) => url.pathname.startsWith("/api/usergroup.php"),
	new NetworkFirst({
		cacheName: "usergroups",
		networkTimeoutSeconds: 3
	})
)

registerRoute(
	({ url }) => url.pathname.endsWith(".pdf"),
	new CacheFirst({
		cacheName: "pdf",
		plugins: [
			new ExpirationPlugin({ maxEntries: 10 }),
		],
	})
)

registerRoute(
	({ url }) => url.hostname === "api.maptiler.com",
	new CacheFirst({
		cacheName: "maptiler",
		plugins: [
			new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 604800 }), // 7 days
		],
	})
)

registerRoute(
	({ url }) => url.hostname === "api.open-meteo.com",
	new NetworkFirst({
		cacheName: "open-meteo",
		networkTimeoutSeconds: 3,
		plugins: [
			new ExpirationPlugin({ maxAgeSeconds: 600 }),
		],
	})
)

registerRoute(
	({ url }) => url.pathname.startsWith("/api/eval.php"),
	new NetworkFirst({
		cacheName: "evaluation",
		networkTimeoutSeconds: 3
	})
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data === "SKIP_WAITING") {
		self.skipWaiting()
	}
})

// Any other custom service worker logic can go here.

self.addEventListener("push", (event) => {
	console.log("Push erhalten: " + event.data.text())
	let options = event.data.json()
	self.registration.showNotification(options.title, options)
})

self.addEventListener("activate", (event) => {
	event.waitUntil(self.clients.matchAll({ type: "window" }).then(clients => {
		clients.forEach(client => {
			client.navigate(client.url)
		})
	}))
})